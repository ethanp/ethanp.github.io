<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: School | With Pith]]></title>
  <link href="http://ethanp.github.io/blog/categories/school/atom.xml" rel="self"/>
  <link href="http://ethanp.github.io/"/>
  <updated>2016-10-10T01:04:45-07:00</updated>
  <id>http://ethanp.github.io/</id>
  <author>
    <name><![CDATA[Ethan Petuchowski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[On Learning]]></title>
    <link href="http://ethanp.github.io/blog/2016/10/09/on-learning/"/>
    <updated>2016-10-09T15:03:32-07:00</updated>
    <id>http://ethanp.github.io/blog/2016/10/09/on-learning</id>
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=Zjm8JeDKvdc">I like to learn things</a>, but I
often feel like time I spend learning things is wasted.</p>

<h3>It&rsquo;s hard to tell what info is going to be useful and what is fluff</h3>

<p>Classes in school (at all levels) lead to lots of wasted effort, because a lot of the stuff you&rsquo;re supposed to learn is simply not useful knowledge. For example, for one college exam, I had to name about 30 different rocks and minerals by sight, and the names are very complicated. People say: &ldquo;well just going through the process is teaching you how to think.&rdquo; I don&rsquo;t disagree, but I think that&rsquo;s a fallacy; learing to think and useful knowledge are not mutually exclusive. Useless knowledge includes specific dates, long names, irrelevant historical events, and other things we might in everyday life dismiss as &ldquo;trivia&rdquo;.</p>

<blockquote><p>In my experience, all academic disciplines have room to reduce the &ldquo;trivia&rdquo; overhead in their curricula.</p></blockquote>

<p>In college computer science classes, there is not a whole lot of trivia. However, their is a &ldquo;jump into abstraction&rdquo; that often left me confused. I quite often didn&rsquo;t understand <em>why</em> what I was learning was important. Edsger Dijkstra said we should teach the abstractions before rotting the students' brains with modern programming realities and deficiencies. That&rsquo;s a laudable mission, but problems still need to be better <em>motivated</em>.</p>

<h4>Difficult material with no motivation is not rewarding</h4>

<p>E.g. during my first Operating Systems course. Everything seemed way more complicated than anything I should ever be expected to know in real life. So I figured I would never end up needing to understand virtual memory, processes and threads, scheduling, networking, etc. In reality, I just had no idea what I was talking about, and that&rsquo;s why it should have been <em>motivated</em>. For example, I have since learned that the Linux kernel has a very interesting open source development ecosystem. They are making upgrades to the thing all the time that affect everyone developing most kinds of modern software. In addition, a whole lot of the different features of computers are motivated by internal business tool usecases, rather than home consumer usecases. Being a college student without a computer nerd background, I had no idea about any of that. Being taught to appreciate how important this stuff would end up being for me would have made me learn drastically more during the course of the class.</p>

<p>What I wanted at that time was for the material to be motivated with an example, like, &ldquo;let&rsquo;s build a program for running a medical radiation machine."Now we&rsquo;re talking; we&rsquo;re going to need to get all the different low-level components right and make them fit together so that we can save lives!</p>

<p>What actually happened was similar in content, but not in objective. We were expected to read a very long and dry paper on the Therac-25, a radiation machine with concurrency issues that killed a few people in the 1980s. I spent a few hours trying to read the paper. One could say I was spending that time &ldquo;learning to think&rdquo;, but I think I spent that time &ldquo;getting nowhere&rdquo;. The whole time I was reading the paper, I was thinking: it would take me so long to get to the point of this paper, and I&rsquo;m not even going to get a whole lot out of it. No good. In the end I learned about the Therac-25 from Wikipedia, a source of information whose expected readership has a level of background knowledge more commensurate with my own. Then, a few years later, I had to read that paper again for a graduate operating systems class, and at that point I had sufficient background knowledge to simply read the paper and feel like I understood its content and learned important lessons about software engineering.</p>

<p>This example demonstrates the fundamental principle that the same content can lead to completely different learning outcomes for different people, and even for the same person at different points of time and (as we shall return to later) in different emotional moods.</p>

<h3>Some keys to not wasting effort</h3>

<ul>
<li>Have something in mind that you want to accomplish with your newly-obtained knowledge

<ul>
<li>E.g. &ldquo;I want to build the software for a medical radiation device&rdquo;</li>
</ul>
</li>
<li>Have someone (colleague) or some place (e.g. stack overflow) where you can ask questions when you get confused

<ul>
<li>Sometimes having another person just <em>explain the whole thing</em> in one shot face to face can lead you to simply <em>just get it</em></li>
</ul>
</li>
<li>Learn the relevant vocabulary for the field on wikipedia

<ul>
<li>For example take at least half an hour digging through linked topics until you have a general grasp of the various concerns and their names, and ideally how they relate to one another</li>
</ul>
</li>
<li>Skim liberally but don&rsquo;t expect to understand what you skim</li>
</ul>


<!-- more -->


<h3>Qualities of time</h3>

<p>During college, I learned from <a href="http://www.aaronsw.com/weblog/productivity">an Aaron Swartz article</a> about how one can&rsquo;t just spend all day reading tough material because it&rsquo;s too mentally strenuous. Instead, you have to choose the right activity for the mood you&rsquo;re in, and there&rsquo;s not a whole lot you can do if you&rsquo;re just not in the mood to learn anything. Mr. Swartz says we should have a todo list that is aware of the fact that different tasks require different levels of mental effort. Maybe after reading my compilers textbook for an hour I&rsquo;m mentally tired and physcally peppy, so I go for a jog. Then I&rsquo;m relaxed and ready to work on writing code for a program. Then I&rsquo;ll get overwhelmed so I step back and plan out some next steps for the program. By now I&rsquo;m sick of the program so I meet some friends. Then I&rsquo;m tired and take a nap. And so on. The point is each activity follows from the next according to my current mental and physical state. So many people don&rsquo;t start the project until the night before, and have to do one strenuous activity all night, fighting exhaustion, and not really getting much out of it because it&rsquo;s all slapped together. Granted, plenty of people are really proficient at getting that strategy to work out.</p>

<h3>Find the right source of information for you right now</h3>

<p>Some places to learn things include youtube, conversations, podcasts, wikipedia, books, tutorials, projects, and blogposts. In terms of enabling lots of deep and useful knowledge to be gained per minute, the most effective might be reading a great book, and doing a great project.</p>

<h4>Try out a few different compiler books</h4>

<p>Finding a great book can be pretty challenging, because you may spend some time reading the wrong books. But it is worth it, because the right book can make a big impact. After looking for some time, I have finally found a <a href="https://www.amazon.com/Writing-Compilers-%20Interpreters-%20Software-%20Engineerin%20g/dp/0470177071/ref=sr_1_sc_1?ie=UTF8&amp;qid=1476048360&amp;sr=8-1-spell&amp;keywords=writ%20ing+compilers+and+interpretere">compilers book</a> from which I am learning what I wanted to know. (It&rsquo;s cover happens to be quite ugly compared to the other compiler books.) Before that I tried reading a hundred pages of each of a few more theoretical compiler books, but over time I decided that for now I&rsquo;m more interested in learning to write the code, over understanding the theory. So the book I found is a tutorial for building a Pascal compiler from scratch in Java, with real executable code accompanying the text. The point is I found a book that is teaching me what I want to know more efficiently than several other popular books on the subject. And I know that from having tried out the other books. I think this is a useful strategy in general.</p>

<h4>Try out a few different algorithms books</h4>

<p>I went through a similar process for learning the fundamentals of algorithms. First I took the class in school and got an A. I can&rsquo;t say that did me much good, as evidenced by failing many easy job interview questions. I didn&rsquo;t like to go to class so someone else would hand in my homework. I studied for the exams directly from the book called &ldquo;Algorithm Design&rdquo;.</p>

<p>After failing at interviews, I started rotating through different algorithms books. I finally sat and (over a few months) read the whole explanatory section of &ldquo;The Algorithm Design Manual,&rdquo; but didn&rsquo;t feel like was walking away with a good grasp of the material it covered.</p>

<p>So I tried to read the classic &ldquo;CLRS&rdquo;. After reading about two chapters then skimming around, I decided I wanted to focus on <em>implementing</em> algorithms instead of proving correctness and complexity bounds.</p>

<p>So I started &ldquo;Algorithms&rdquo; by Sedgewick and Wayne. It started off pretty slow, so I found that by skimming, I was able to read a few hundred pages in the first few hours, which wasn&rsquo;t productive but motivated me to get into some more challenging material. So I skimmed up to a lot of material that I didn&rsquo;t already know (I think chapter 2 or 3).</p>

<p>In addition to incredible explanations, the book has clean code, amazing diagrams, easy, medium, and hard code and theoretical exercises, a full sequence of lecture videos by Dr. Sedgewick himself, etc. With this mix, I was finally able to achieve a satisfying learning per minute score. In general, I was able to just &ldquo;follow along&rdquo; with the book and understand things as they came.</p>

<p>The whole time I was reading this book, whenever I found a concept hard to grasp, based on my bad experiences with other books and classes and tutorials, I could rest assured that it would be unlikely that I could find a better explanation elsewhere. This attitude strengthened my resolve, and I ended up reading and understanding almost everything in the book.</p>

<h3>Maybe it&rsquo;s just the tone</h3>

<p>I have always been deeply affected by the tone in which information is presented to me in turms of being able to remember it. So have you, just ask your parents. I&rsquo;ve had professors I couldn&rsquo;t stand teach me subjects I love and walked away with nothing from that class. And vice versa. Everyone knows that. It&rsquo;s the same with textbooks. I think the key is inspring the student about the potential of what they can do with the knowledge, and to actually convey the excitement of it!, instead of simply boring you to tears with facts.</p>

<p>One thing the Khan Academy (among others) has brought to teaching is excitement for the actual content. The end result is that people (e.g. me) can actually bear to spend hours watching and re-watching Mr. Khan explain differential equations. He&rsquo;s doing a taylor series expansion, and he&rsquo;s like &ldquo;just check out how cool this is!&rdquo; and I&rsquo;m like &ldquo;yeah, expand that shit!&rdquo; Whereas otherwise I&rsquo;d be sitting at class at 8:30 in the morning like, &ldquo;FML I can&rsquo;t believe I&rsquo;m not sleeping right now&rdquo;. Junior year of college, without Khan Academy&rsquo;s help (and <em>Paul&rsquo;s Online Notes</em>, a free math textbook), there&rsquo;s no way I would have done so well in diff-eq, which gave me the confidence to transfer into a computer science degree later on.</p>

<h3>When to skim</h3>

<p>Most of the time, skimming material does not lead to understanding the material. Instead, it only leads to some kind of <em>awareness</em> of the material; that feeling later of &ldquo;yeah I think I&rsquo;ve seen this stuff before&rdquo;. That said, skimming is often crucial, especially for reading blogposts.</p>

<p>Blogposts may be written with any of an assortment of aims.</p>

<p>For example, the author may be trying to assert her expertise in an area by providing a good explanation, in order to further her career. Those vary widely in quality, and can occassionally be read deeply for understanding. Data science has a <em>huge</em> number of those.</p>

<p>Or the author may be trying to clear up his own thoughts on some subject. That&rsquo;s what I&rsquo;m trying to do here. In that case, skim to find the parts that are relevant or entertaining, and read those.</p>

<p>Or it may be written for the author to remember something, like &ldquo;how to get HDFS running locally on Mac&rdquo;. Thank heavens for such blogposts.</p>

<p>Or it may be some sort of <em>war story</em>: &ldquo;this is what we did, and this is how it worked out&rdquo;. If you&rsquo;re trying to build a complex system, you probably want to read some of those.</p>

<p>Lectures are generally only worth skimming. It takes me less effort to understand a lecturer than to understand a book. But even when it&rsquo;s clearly stated, the lecturer is generally not divulging much information, and when they start to say something actually complicated, it becomes easy to zone out, get lost, and lose interest. They may also get lost on side-tracks or try to pull things in that they think are cool. A great lecturer can be a very entertaining way of learning, but it&rsquo;s generally not time spent learning nearly as much substance as can be read from a page. Please note, hour long lectures are quite different from a super-helpful and targeted 5 minute youtube video.</p>

<p>One useful question to ask before reading something is &ldquo;Can I just skim it?&rdquo; The answer to this is yes if you <em>don&rsquo;t</em> want to be able to actively use that knowledge in the future. Often, skimming is useful for verifying that you understand something that you learned about elsewhere. For example, if I were to skim a tutorial on parsing theory, I would be able to roughly guage how much of that stuff I actually understand based on how much I&rsquo;m recognizing concepts and &ldquo;agreeing with the author&rdquo; as I skim.</p>

<p>A frustrating situation is to read something deeply when you could have just skimmed it because there was nothing really there. Maybe this can be avoided by skimming first to see whether it&rsquo;s even worth really reading. But I never do that.</p>

<p>Another time skimming is useful is when you&rsquo;re stuck. When I got stuck reading about computer architecture, I would go back to the table of contents. &ldquo;How did I get to where I am?&rdquo; &ldquo;Where are we going with this stuff?&rdquo; &ldquo;What do I find interesting about this?&rdquo; Then I would skip to some figures. Look at the figure. Is it cool looking? Wouldn&rsquo;t it be fun to understand what it means? Let&rsquo;s look at some of the keywords in the text near the figure. Oh there&rsquo;s some words I&rsquo;ve seen before but didn&rsquo;t understand, I guess they were important. Now I can go back to their definitions and see if I can place them properly in the figure. And so on.</p>

<h3>Is learning important</h3>

<p>By getting better at seeking out the best sources of information, we build an improved ability to affix knowledge into the brain accessibly, without expecting the best educators to just to fall in our lap when we need them. Here, I have tried to explore and share some lessons about building the conditions for learning efficiently.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Asking for Advice]]></title>
    <link href="http://ethanp.github.io/blog/2016/02/27/asking-for-advice/"/>
    <updated>2016-02-27T15:38:06-08:00</updated>
    <id>http://ethanp.github.io/blog/2016/02/27/asking-for-advice</id>
    <content type="html"><![CDATA[<p>There are many circumstances in life during which one may feel the need to ask
for advice. For example, when evaluating a significant decision, or when
dealing with an emotionally stressful circumstance. Here, I will discuss
advice about significant decisions.</p>

<p>In giving advice, everyone has a different approach. I generally try to follow
a line I heard in a rap song by The Streets, &ldquo;If you never tell a lie to her,
you don&rsquo;t have to remember anything.&rdquo; In other words, lying will only
complicate your life because you have to remember the lies you made up.
(Caveat: this may not always the best way to go for emotionally complex
issues.) I also enjoy helping people rationally and realistically evaluate
their options for significant decisions, and surely if someone recalls that
your input was helpful in the past, they will be more likely to ask you in the
future.</p>

<p>Most people I know don&rsquo;t seem to like giving useful advice. It seems they
either are (1) too afraid that their honesty will lead you to dislike them, or
(2) they feel so stressed with their own issues that taking on yours for a few
minutes would be overwhelming, or (3) they find your problem uninteresting and
simply have better things to do.</p>

<p>But some people are the opposite. They will patiently listen to your question
and give what they feel to be an honest evaluation of where you stand and what
you should do. The advice of people in this category will often be heavily and
obviously biased by their own experience and ideology. This is simply a
symptom of &ldquo;being honest&rdquo;.</p>

<p>So if you want good advice, it would be ideal to find someone who is honest,
not stressed about a similar problem to yours, as well as interested in and
knowledgeable of the subject; they should generally also be disinterested in
your particular problem. However, this ideal candidate is not always
available.</p>

<!-- more -->


<p>In that case one can obviously try the timeless &ldquo;pros vs cons&rdquo; list, which
doesn&rsquo;t necessarily rely on external sources of wisdom, but often external
sources of wisdom are critical. One can ask unideal candidates for advice, and
maybe they&rsquo;ll at least have some curt nugget that has some use. That&rsquo;s what I
usually do, and it is generally not effective at all, but occasionaly that
curt nugget is exactly the required pithy jewel.</p>

<p>One can consult the Internet, but I kind of assumed that if you needed advice,
you already checked the Internet for answers. But to go one step further you
can <em>ask</em> the Internet, treating it like this all knowing Oracle. This will
work to varying degrees depending on your problem. If your problem is one that
everyone and their mother has an opinion on, you will end up sifting through
junk answers, and may or may not get anything useful. In that case, the more
details you can reveal, the more benefit you will obtain. Of course <em>where</em>
you ask matters: for example Quora will be more effective than Yahoo Answers.
If your problem is esoteric, <em>find the people who are into that thing</em>.</p>

<p>For example, I have noticed to my surprise that StackOverflow/StackExchange is
not always the best place for all programming-related questions, because if
your question is esoteric to one technological ecosystem, the question-
answering population on StackOverflow won&rsquo;t necessarily have the flag-bearers
of the cause of that particular ecosystem. But if it really is an ecosystem,
it will have a place where the flag-bearers dwell, so <em>find it</em> and they will
probably help. In my experience, IRC channels tend to be empty; Gitter
channels may be well-attended; Github issues get a lot of flak for being a
mess, but are often effective if you&rsquo;re sure your question isn&rsquo;t stupid;
mailing lists can be high-latency but that&rsquo;s often where the true experts of
super-technical projects converse. Following <strong>good forum-question-asking
practices</strong> is <em>crucial</em> in <em>any</em> of these environments, and it can be
trickier to do that than it sounds. <strong>The better you phrase your question, the
more appealing it is to answer in the eyes of a high-quality potential source
of advice.</strong></p>

<p>Sometimes the advice you receive from multiple sources will be in direct
conflict with each other. I have been having this issue a lot lately. Let&rsquo;s
say one person suggested I do <code>A</code>, and another suggested I do <code>not A</code>. I have
decided this pair of suggestions implies that <em>either</em> decision is just fine,
which is basically the ideal outcome; viz. my so-called &ldquo;significant decision&rdquo;
was not so significant after all and doesn&rsquo;t not need to be balanced
carefully.</p>

<p>Just some biased thoughts from my experience; take some, leave some, etc.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why the WiFi Sucks on the Porch]]></title>
    <link href="http://ethanp.github.io/blog/2015/09/24/why-the-wifi-sucks-on-the-porch/"/>
    <updated>2015-09-24T14:31:30-07:00</updated>
    <id>http://ethanp.github.io/blog/2015/09/24/why-the-wifi-sucks-on-the-porch</id>
    <content type="html"><![CDATA[<h2>Why is WiFi so slow on the porch?</h2>

<p>The problem at my house is that WiFi connectivity is generally fine inside the
house, but while sitting on the porch it is nearly impossible for anyone to
browse the Hinternets. I think a lesson of my <a href="http://www.cs.utexas.edu/~lili/classes/F15-CS386W/">Wireless Networking</a> course
explains this observation.</p>

<p>In Wireless networking we have the situation called the <a href="http://www.wikiwand.com/en/Hidden_node_problem"><strong>Hidden Terminal
Problem</strong></a>, which is the following. Node <code>A</code> is too far from node <code>C</code> to
hear its transmissions, but both are in range of node <code>B</code> which sits between
<code>A</code> and <code>C</code>. Suppose <code>C</code> is currently transmitting data to <code>B</code>. Now <code>A</code> checks
whether any transmissions are currently happening, and finds that there are
none (because it is out of range of <code>C</code>). So <code>A</code> goes ahead and sends data to
<code>B</code>. Now <code>B</code> can&rsquo;t understand either data packet because they collided and
interfered with each other in an unrecoverable way because they were both sent
in the same channel.</p>

<p>I think the porch scenario is simply an example of the <em>Hidden Terminal
Problem</em> above. In my room, my laptop can hear many of my neighbors' WiFi LAN
networks, but it&rsquo;s the same set that my WiFi router sitting in the closet can
hear. However outside, where there&rsquo;s less cause for signal attenuation, my
laptop can hear many more WiFi LAN networks than the router inside. So the
router checks whether there is congestion, doesn&rsquo;t hear any, and sends the
data. But there <em>is</em>, in fact, congestion, and my computer doesn&rsquo;t receive the
data properly. The data is therefore not <em>ACKd</em>, the router times out on the
<em>ACK</em>, and has to retransmit, and so on. This makes for a <em>far</em> slower
Hinterconnectivity outside on the porch than in my room.</p>

<p>Maybe the lesson learnt is that the WiFi router should be situated in a place
where it can hear more of the outside noise so that it can compensate better
for that noise.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Basics of Wireless Communication]]></title>
    <link href="http://ethanp.github.io/blog/2015/09/07/basics-of-wireless-communication/"/>
    <updated>2015-09-07T15:45:58-07:00</updated>
    <id>http://ethanp.github.io/blog/2015/09/07/basics-of-wireless-communication</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been doing the readings for my <a href="http://www.cs.utexas.edu/~lili/classes/F15-CS386W/">Wireless Networking course</a> at
UTexas, and in the process have dug into much of the basics of radios and
networks that I had ignored in the past. Here, I will try briefly describe what
I have learned. Maybe not everything I will say here is exactly correct, but I
think it&rsquo;s at least <em>mostly</em> correct.</p>

<p>Let&rsquo;s try to start somewhere near the beginning. Our <strong>goal</strong> is to transfer a
<em>information</em> from one location <code>LocSND</code> to another <code>LocRCV</code> <em>conveniently</em>.
The way we will accomplish that is by having <code>LocSND</code> manipulate the
<em>electromagnetic field</em> around <code>LocRCV</code>. More specifically, we will <em>encode</em> a
binary <em>dataframe</em> as <em>modulations</em> of a <em>radio signal</em> around a pre-determined
<em>carrier frequency</em>.</p>

<p>How do we <em>do</em> that?</p>

<!-- more -->


<p>We use an LRC circuit to make electrons oscillate in an
antenna. These oscillating electrons ram into loose and excitable electrons in
the antenna&rsquo;s metal, this releases a photon at a particular frequency. Globally
(i.e. within the entire transmitting antenna), enough photons are being
released that it seems to an external observer looking at the produced
electromagnetic (EM) field like there is a continuous signal being emitted.</p>

<p>So we&rsquo;re sending these EM ripples, which are generally at our carrier
frequency. However, if we just sent a basic frequency, there would be no
<em>information</em> in there, so we have to <em>modulate</em> it. We can modulate its
amplitude (A), phase (phi), and frequency (omega), the 3 free
parameters of the equation (in the top left of the equation in the following
gif from &ldquo;sengpielaudio&rdquo;)</p>

<p><img src="http://www.sengpielaudio.com/Sinuskurve01.gif" alt="sine wave" /></p>

<p>This would give us
1. <strong>Carrier frequency</strong> &mdash;&ndash; the EM frequency <em>inside</em> which our signal is
  encoded
2. <strong>amplitude shift keying (ASK)</strong> &mdash; send signal at <em>carrier frequency</em> by
   modulating the signal&rsquo;s <em>amplitude</em>
3. <strong>frequency shift keying (FSK)</strong> &mdash; similar but modulates <em>frequency</em>
4. <strong>phase shift keying (PSK)</strong> &mdash; again, but modulates <em>phase</em></p>

<p>One simple method would be to say our carrier frequency is 5 Hz, but our band
is actually [4,6] Hz. So whenever the signal is 4 Hz, that means I&rsquo;m sending a
0, and if the signal is 6 Hz, it means I&rsquo;m sending a 1, and a new digit starts
every 1 ms. That would be an example of <strong>FSK</strong>.</p>

<p>A fundamental problem that we must solve is that all senders and receivers of
information via EM fields with their antenna(s) are sharing the a single
<em>medium</em> for transmitting that field (viz. the air, etc.). So if <code>LocSND</code> sends
a message to <code>LocRCV_1</code>, then <code>LocRCV_2</code> sitting one foot away can hear that
message loud and clear. This leads to three major issues: <strong>security</strong>,
<strong>multiplexing</strong>, and <strong>interference</strong>.</p>

<p>To <strong>multiplex</strong> means to send multiple distinct signals through a single
channel. How are we going to send distinct signals to receivers 1 and 2 in such
a way that both can understand the signal meant for them? We can chop up the
frequency band that our transmitter can use into 2 smaller bands, and use each
of those bands as separate carriers. Then we tune the receivers to pick up
frequencies in their respective bands. This is what is called <strong>frequency
division multiplexing (FDM)</strong>, but we can also multiplex across space, time,
and <em>code</em>.</p>

<p>Of course, I&rsquo;ve only scratched the very surface of what&rsquo;s going on here, but
that&rsquo;s all the time I&rsquo;ve got.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simulating a Distributed System]]></title>
    <link href="http://ethanp.github.io/blog/2015/05/18/simulating-a-distributed-system/"/>
    <updated>2015-05-18T17:24:37-07:00</updated>
    <id>http://ethanp.github.io/blog/2015/05/18/simulating-a-distributed-system</id>
    <content type="html"><![CDATA[<p>For my Distributed Computing class at school, there were 3 projects that each
involved implementing a distributed protocol over a simulated distributed
cluster of computers that are only &lsquo;connected&rsquo; to one another in that they know
each other&rsquo;s IP address and must communicate over TCP sockets. For each of the
3 projects, I had a <em>completely</em> different method of implementing the system.</p>

<h3>Implementation One: A True Distributed System in Vanilla Java</h3>

<p>The first project (Three Phase Commit) was the only one for which I worked with
a partner. We were unclear how to attack the problem of building a distributed
system in a simple way, so we went ahead and implemented a truly distributable
Java application, in which you could spin up processes on any computer and it
would connect in to the master server, who would tell the new node the
listening ports of other servers in the cluster manually, etc. This turned out
to be perhaps overly ambitious. When a node was expecting a message from
someone else, it would fire a timer thread, which on completion would report to
the master to restart the failed process. This system did work properly
(somehow) but it seemed to be living-on-the-edge. It also required two weeks of
a lot of working on it and learning aspects of Java, unit testing, mocks, which
<code>Exception</code> would get thrown by which network event &amp; when, etc.</p>

<h3>Implementation Two: Lightweight System Simulation</h3>

<p>For the second project (Paxos), I said &ldquo;Hooey&rdquo; to all the Java hubbub, which
while I enjoyed its low-level-ness, forcing me to peak further under the hood,
it required a larger time commitment than I was prepared to make. I realized
that my class&rsquo;s requirements only specified that system &ldquo;nodes&rdquo; run
concurrently, share no memory, and talk over TCP. So in Scala, I made a <code>Node</code>
class state machine, and ran different instances of it on separate threads.
This was too easy though, and I was disappointed to find my implementation
complete more than two weeks before the due date.</p>

<h3>Implementation Three: Akka Cluster</h3>

<p>Akka Cluster is a Scala-based framework for building a distributed system, in
which you define the address of a set of &ldquo;seed&rdquo; nodes, of whom at least one is
supposed be available at all times. Then when other nodes start up, they become
a &ldquo;member&rdquo; of the cluster by contacting any seed node. So for me (the &ldquo;client&rdquo;
of Akka Cluster), all there is left to do is define the protocol to run on top
of the cluster. (In this case the protocol was the simple eventually-consistent
database protocol &ldquo;Bayou&rdquo;.)</p>

<p>Akka nodes follow the &ldquo;Actor Model&rdquo;, meaning they share no state with any other
part of your program, making them &ldquo;simple&rdquo; to run on remote machines (I didn&rsquo;t
try that, the docs say it is easy though). The only way actors can communicate
is via message passing, for which there is a dedicated syntax, <code>!</code>. For
example:</p>

<p><code>scala
case class MyMessage(data: DataElem)
anotherActor ! MyMessage(theData)
</code></p>

<p>The code above would have the actor running this code, send <code>anotherActor</code> an
instance of the case class <code>MyMessage</code> with the <code>DataElem</code> that was passed in.</p>

<p>Inter-actor communcation is guaranteed <em>FIFO</em> by Akka, meaning that for any
pair of actors <code>A, B</code>, if <code>A</code> sends <code>n</code> messages to <code>B</code>, <code>B</code> will receive those
messages in the same order that <code>A</code> sent them. NB this says nothing about the
order with respect to other actors in the system.</p>

<p>Using Akka trivialized all sorts of implementation details I&rsquo;d had to worry
about in the first project, and then ignored for the second project.</p>

<p>If there had been a 4th project for this class, it&rsquo;s clear to me that I would
use Akka again. For some reason my code ran <em>very</em> slowly, and it probably had
to do with some configuration-setting that I did not set in the Akka config
file. That was really the only problem I had that I did not fix. One problem I
did fix that took a while, was figuring out a good way to shut the system down.
There were various options discussed online, and eventually I found one that
worked for me, which was to call <code>system.shutdown()</code> on every instance System I
instantiate. Another option was to send <code>self ! PoisonPill</code> but for some reason
that didn&rsquo;t work. I guess different ones work for different situations.</p>
]]></content>
  </entry>
  
</feed>
