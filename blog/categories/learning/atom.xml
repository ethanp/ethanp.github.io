<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Learning | With Pith]]></title>
  <link href="http://ethanp.github.io/blog/categories/learning/atom.xml" rel="self"/>
  <link href="http://ethanp.github.io/"/>
  <updated>2016-04-10T23:33:38-07:00</updated>
  <id>http://ethanp.github.io/</id>
  <author>
    <name><![CDATA[Ethan Petuchowski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gamified Learning]]></title>
    <link href="http://ethanp.github.io/blog/2016/01/03/gamified-learning/"/>
    <updated>2016-01-03T21:34:05-08:00</updated>
    <id>http://ethanp.github.io/blog/2016/01/03/gamified-learning</id>
    <content type="html"><![CDATA[<p>I have spent the last few days trying to get better at programming. I am no
longer in school, so if I want to learn about, say, compilers, I can&rsquo;t just
sign up for a class on that. There are multiple ways to go about it. It depends
on what you really want to learn and what you want to be able to do with that
knowledge. I have tried various methods of learning over the past few days,
which I have listed below.</p>

<p>What I have noticed of myself is that gamification <strong>works</strong> for me. I love the
satisfaction of (in descending order of [perceived] satisfaction)</p>

<ul>
<li>earning a badge</li>
<li>getting to the next level</li>
<li>beating other humans (directly, or via &ldquo;percentile&rdquo; calculation)</li>
<li>beating robots (similar to &ldquo;beating a boss&rdquo; in a video game)</li>
<li>getting points</li>
</ul>


<!-- more -->


<p>Missing from the list below is Coursera, Udacity, etc. After 6 years of school,
I&rsquo;m <em>really</em> of sick of sitting in a lecture hall, even if it&rsquo;s a virtual one.
As a testament to this sentiment, so far I&rsquo;ve read ~150 pages of the Compilers
textbook, which is the book I would be reading were I to take the class at
University. Sometimes I miss having a teacher whose personality I can associate
with the material. This is a bizarre notion, but it is really important. For
me, having a &ldquo;great teacher&rdquo; means someone I want to please by doing well on
the test. Having a &ldquo;bad teacher&rdquo; means I don&rsquo;t care what the teacher thinks of
me, and frankly I want to do badly to make them feel bad. This is a mean way of
looking at the world, and I don&rsquo;t do it consciously, but looking back at how I
approached my classes, this is what I did a lot of the time. Having a &ldquo;great
teacher&rdquo; is an amazing feeling, and an excellent motivator to really dig into
the subject. But I certainly <em>don&rsquo;t</em> miss all the other crap that comes from
having a teacher (even a &ldquo;great&rdquo; one). The main problem with teachers is that
you need to be respectful of their time and the time of the other students in
the class. This leads to a huge amount of wasted time on the part of each
student, because his or her <em>particular</em> questions aren&rsquo;t being answered. I
could go on about that but I won&rsquo;t. The point is, that I really
feel like I understand everything that has happened so far in the 150 pages of
the Compilers book, and it didn&rsquo;t require and physical hand-holding. It is
exceptionally easy to read a book and think you understand it, and actually
<em>not</em> be understanding it. So who knows.</p>

<h3>Here on out</h3>

<p>My first &ldquo;real&rdquo; day of my first &ldquo;real&rdquo; job is tomorrow. So I probably won&rsquo;t be
spending much time just randomly learning whatever I want in the future. But in
general, these are things that I like to learn about, and methods of learning
them that I enjoy doing; so as I find time, I will come back to these things.</p>

<h3>The List</h3>

<p>This list contains bullets for each thing I have tried to learn over the past
few weeks. The sub-bullets contain methods I have used to actually <em>do</em> the
learning. Many of them are gamified methods of learning (e.g. HackerRank).
Others, I have tried to gamify on my own (e.g. using test-driven development).</p>

<ul>
<li>Learn about compilers

<ul>
<li>read Compilers &ldquo;Dragon Book&rdquo; textbook

<ul>
<li>avg 8 pages per day for 20 days</li>
</ul>
</li>
<li>do the exercises (on paper)</li>
</ul>
</li>
<li>Review AI &amp; machine learning

<ul>
<li>earn an AI &ldquo;badge&rdquo; on HackerRank by

<ul>
<li>doing statistics problems (e.g. &ldquo;find the z-score&rdquo;)</li>
<li>writing a few programs (e.g. &ldquo;do a multiple linear regression on the
given data&rdquo;)</li>
</ul>
</li>
</ul>
</li>
<li>Become more familiar with algorithms and their application

<ul>
<li>do practice problems on Hackerrank</li>
<li>Read [from] the algorithms textbook &ldquo;CLRS&rdquo;</li>
</ul>
</li>
<li>Become a &ldquo;good programmer&rdquo;

<ul>
<li>write the programs suggested in &ldquo;Programming Pearls&rdquo; by Jon Bentley</li>
<li>Beat bots and people at debugging code on <code>codefights.com</code></li>
</ul>
</li>
<li>Learn via observation

<ul>
<li><code>Livecoding.tv</code> (haven&rsquo;t actually looked into this one yet)</li>
<li>Annotate the code of small open source projects with comments explaining
how it is working

<ul>
<li>substack &mdash; creator of popular modules for Node.js</li>
<li>Li Haoyi &mdash; Scala projects using concepts from compilers</li>
</ul>
</li>
</ul>
</li>
<li>Understand P2P networking

<ul>
<li>Create a personal &ldquo;open source&rdquo; programming project that is a P2P
networking application

<ul>
<li>To a large extent using test-driven development</li>
</ul>
</li>
</ul>
</li>
<li>Learn to use NodeJS

<ul>
<li>do the <code>learnyounode</code> interactive tutorial</li>
</ul>
</li>
<li>Learn about functional programming

<ul>
<li>read from Learn you a Haskell</li>
<li>write some simple haskell programs as part of a &ldquo;learn to code in 30
days&rdquo; competition on HackerRank</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning vs Doing]]></title>
    <link href="http://ethanp.github.io/blog/2015/12/19/learning-vs-doing/"/>
    <updated>2015-12-19T14:05:20-08:00</updated>
    <id>http://ethanp.github.io/blog/2015/12/19/learning-vs-doing</id>
    <content type="html"><![CDATA[<p>The goal of my first project at my first &ldquo;real&rdquo; job is to get something useful
done within a few days and start to feel like a contributing member of the
team. However it has been about a week, and I still have not finished that
project.</p>

<p>From my experience talking with some of my colleagues so far, their collective
attitude might be summed up with, &ldquo;Google it, then copy-paste it, but don&rsquo;t
worry about what it does.&rdquo; In my life, I have worked with and met <em>many</em> people
having that attitude. Partially because of my experience working with those
people, it happens to decidedly <em>not</em> be <em>my</em> attitude. My attitude is more
like &ldquo;google it, learn what to do, learn why that is the right approach, take
notes, and then copy-paste and modify the best solution to make the final
solution as clean as possible.&rdquo; This strategy got me through many tough
situations, so I have built up faith in it.</p>

<p>So, after seeing me spend <em>days</em> learning about ssh tunnelling, ansible, and
vagrant &mdash; and not finishing my simple project &mdash; they finally said something
along the lines of</p>

<blockquote><p>At this rate it will take you weeks to learn how to automate deployment of a
virtual machine. Why don&rsquo;t you just deploy <em>one</em> copy and then learn about
how to automate it on your <em>own</em> time?</p></blockquote>

<p>Now, &ldquo;weeks&rdquo; is probably an overstatement, but they pointed out to me that I
had sort of assumed out of nowhere that I was hired as some sort of devops role
for the company, even though what I&rsquo;m actually interested in is what one might
call &ldquo;big data engineering&rdquo;. They said, &ldquo;<em>If</em> you find yourself repeating the
same tasks over and over, <em>then</em> you should learn to automate them.&rdquo; It is now
obvious that they are in the right.</p>

<p>At the time, I was startled by the way they approached me about what I consider
to be largely a difference in personalities. But I can see that they are
concerned that someone who reads too much never gets anything done, and so far
I have fit that stereotype. At the same time, I am concerned that a person who
<em>doesn&rsquo;t</em> read will do their work quickly and incorrectly and will then spend
the next few weeks rejiggering a broken project, and so far they have fit that
stereotype. In short, it seems that we are all prejudiced and have plenty to
learn from each other.</p>

<p>Going forward I shall take their advice and do the more mundane tasks as fast
as possible and only learn things that come up more than once. If that doesn&rsquo;t
work out for me because I&rsquo;m just cranking out shitty work, I will revert back
to understanding what I am doing.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Workflow and Scripts for Learning From Github]]></title>
    <link href="http://ethanp.github.io/blog/2015/08/11/a-workflow-and-scripts-for-learning-from-github/"/>
    <updated>2015-08-11T17:48:41-07:00</updated>
    <id>http://ethanp.github.io/blog/2015/08/11/a-workflow-and-scripts-for-learning-from-github</id>
    <content type="html"><![CDATA[<h3>My &ldquo;Learning&rdquo; Workflow</h3>

<p>As I wrote about <a href="http://ethanp.github.io/blog/2015/08/06/how-apm-originally-worked/">before</a>, I have developed an interesting method of learning
from experts, which can be summarized as follows:</p>

<ol>
<li>Fork their repo on GitHub</li>
<li>Clone the repo locally and &ldquo;detach the <code>HEAD</code>&rdquo; to the &ldquo;inital commmit&rdquo;</li>
<li>Now repeat the following <code>while (curious)</code>

<ol>
<li>Open the working tree in an editor/IDE</li>
<li>If there&rsquo;s something runnable, run it</li>
<li>Understand everything going on in the working tree

<ul>
<li>Take hints from the commit message</li>
</ul>
</li>
<li>Advance <code>HEAD</code> one commit</li>
<li>View the diff from the previous commit</li>
</ol>
</li>
</ol>


<!-- more -->


<h3>SourceTree cannot handle this workload</h3>

<p>I have always used Atlassian&rsquo;s Git GUI called SourceTree for all of my Git
usage because it is a <em>great</em> application, but the fact is, it will not work
for the workflow above. SourceTree has to rebuild the list of commits <em>all the
time</em> (startingfrom the most recent), and when there are thousands of commits,
that can take about a minute. But since I&rsquo;m always operating at the beginning
of the reverse end of the commit log, using SourceTree is untenable. For
whatever reason they decided it was a better idea not to keep all these commits
in memory after they are loaded the first time. I&rsquo;m not saying that was a bad
decision, because my workflow here may be <em>atypical</em>.</p>

<h3>Git is a DAG pointing back in time</h3>

<p>From what I understand&mdash;which is not (yet) a whole lot&mdash;Git is a DAG of
&ldquo;snapshots&rdquo; of the state of your project. Each snapshot points to its parents.</p>

<p>In a typical case, you&rsquo;ll load a snapshot, edit your working directory, add the
changes into the staging area, and <strong>commit</strong> a new snapshot which equals the
previous snapshot, plus the staged changes. Now your new commit has <em>one</em>
parent: the previous snapshot.</p>

<p>A <strong>merge commit</strong> would have <strong>two parents</strong>: the previous commit on the
branch being committed to, and the previous commit on the branch being merged-
in.</p>

<h3>The Learning workflow flows the wrong way</h3>

<p>The Learning worflow would require pointers to the <em>next</em> commit, not just
back-pointers. So it doesn&rsquo;t quite fit the Git mold, and we require a
workaround.</p>

<p>That&rsquo;s where StackOverflow saves the day. <a href="http://stackoverflow.com/questions/2121230/git-how-to-move-back-and-forth-between-commits/23172256#23172256">Here</a> someone modified
a StackOverflow answer by someone else to a <em>related</em> question, and produced
wrappers that help you traverse back and forth between commits. I reproduce an
explicated and slightly simplified version below which may be added to your
shell config file.</p>

<p>```scala</p>

<h1>checkout prev (older) revision</h1>

<p>git_prev() {</p>

<pre><code># move HEAD "one" generation back along *this* branch
git checkout HEAD~1
</code></pre>

<p>}</p>

<h1>checkout next (newer) commit</h1>

<p>git_next() {</p>

<pre><code># git show ref:
#       show (commit-sha, ref-name) pairs for current-versions of all 
#       "refs"; i.e. tags, remote branches, and local branches
# 
# git show-ref -s HEAD:
#       get sha of latest commit on branch pointed to by HEAD
#
# BRANCH=...:
#       get the name of the branch HEAD is on
#
BRANCH=`git show-ref | grep $(git show-ref -s HEAD) | sed 's|.*/||' | grep -v HEAD | sort -u`

# get the hash of the latest commit on the current branch
HASH=`git rev-parse $BRANCH`

# git rev-list --topo-order HEAD..$HASH:
#       list all commit sha's in order on the current branch from
#       HEAD until now 
#
# @return the commit sha for the commit after HEAD on branch
#
PREV=`git rev-list --topo-order HEAD..$HASH | tail -1`

# move head to the next commit
git checkout $PREV
</code></pre>

<p>}
```</p>

<p>With that knowledge in tow, I also made a little command to jump to the <em>i</em>&lsquo;th
commit on master. If you&rsquo;re trying to jump to the <em>i</em>'th commit on the current
branch, get the current branch using the <code>BRANCH=...</code> code above, and pass it
to <code>rev-list</code>.</p>

<p>```scala
gitj() {</p>

<pre><code>git checkout `git rev-list master | tail -n$1 | head -n1`
</code></pre>

<p>}</p>

<p>$ gitj 1    # jump to initial commit of master
$ gitj 3    # jump to third commit
```</p>

<h3>Wrappin it up</h3>

<p>So yeah, now the workflow is simpler to use and it was made possible by gaining
a better understanding of how Git works.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lesson Learnt About Collaboration]]></title>
    <link href="http://ethanp.github.io/blog/2015/07/22/lesson-learnt-about-collaboration/"/>
    <updated>2015-07-22T21:16:25-07:00</updated>
    <id>http://ethanp.github.io/blog/2015/07/22/lesson-learnt-about-collaboration</id>
    <content type="html"><![CDATA[<p>Perhaps the greatest lesson of this summer has been in taking advantage of the
power of collaboration.</p>

<p>When my boss decided to hire me, he told me that it was in large part because
of my communication skills. I don&rsquo;t know if he still agrees with this, but I
like to think it is true.</p>

<p>One of my greatest prides is the ability to openly lose an argument. For a long
time, this has quite often been my reason for entering an argument, and I try
to make it easy to lose. If someone seems to know they&rsquo;re right, we must
together find the bridge of what I&rsquo;m missing that will be convincing beyond a
reasonable doubt of their correctness. Making it easy to lose means figuring
out what you <em>actually</em> think, making that clear, and not wavering from that
initial point of view even when more facts come to light. Or at least
acknowledging that the original viewpoint was incorrect, and now <em>this</em> is what
I [honestly] believe to be true. A regrettable human tendancy is to change
one&rsquo;s opinion during an argument as the facts come to light because &ldquo;with these
facts, my original point of view was wrong, and clearly I wasn&rsquo;t wrong, so that
couldn&rsquo;t have been my real point of view.&rdquo; This needs to be consciously
avoided.</p>

<!-- more -->


<p>But still, I haven&rsquo;t always taken advantage of opportunities to collaborate.
There is a lot of overhead when working with a partner. A lot of your time is
spent explaining to them stuff you already know. These could be things which
took quite a while of staring at text trying to understand, and now it feels
like you&rsquo;re letting them off the hook by just explaining it outright. Sometimes
there are petty disagreements in which I like to code things my way and she
hers, etc.</p>

<p>One small example is that in one project I wanted the code for a very
complicated function to have the following structure</p>

<p>```scala
def complicated1() {</p>

<pre><code>val precondition1 = state1 != invalid &amp;&amp; state2 != invalid
val precondition2 = state3 != invalid || state4 != invalid
val preconditionsMet = precondition1 &amp;&amp; precondition2
if (!preconditionsMet) {
    logError("error 1")
    return // early escape
}
val computationResult = doSomeComputing()
if (!isValid(computationResult)) {
    logError("error 2")
    return // another early escape
}
// the main logic here
</code></pre>

<p>}
```</p>

<p>whereas my partner wanted something more along the lines of the following</p>

<p>```scala
def complicated2() {</p>

<pre><code>if (state1 != invalid &amp;&amp; state2 != invalid
 &amp;&amp; (state3 != invalid || state4 != invalid)) 
{
    val computationResult = doSomeComputing()
    if (isValid(computationResult)) {
        // the main logic here
    }
    else {
        logError("error 2")
    }
}
else {
    logError("error 1")
}
</code></pre>

<p>}
```</p>

<p>It&rsquo;s a petty issue; either way the <em>exact</em> same code is going to execute, and
we each had very good reasons for finding our own way easier to understand. We
didn&rsquo;t bicker over it because we got along very well, and in the end we
actually did it my way. But in reality the actual function was considerably
more complex, and perhaps there were entirely better ways of structuring it
that neither of us noticed.</p>

<p>Now, at work, there is a new-hire considerably more senior and experienced than
I, who started 2 days ago, and who is taking over my project once I go back to
school in a few weeks; so it has been my responsibility to teach him how
everything works. Very often, he feels the need to obsessively ask me: &ldquo;Your
code that says <code>3 + 4</code>, that means you&rsquo;re adding 4 to 3, right?&rdquo; Sometimes he
says &ldquo;right?&rdquo; and I say yes, then he repeats what he said and I repeat &ldquo;yes,
you are correct&rdquo;, and this can continue and I wonder what he is getting out of
that.</p>

<p>At first I resented this because it sometimes felt like no one taught <em>me</em> much
about the codebase when I arrived; for the more complex bits, I just stared at
it until it clicked. This was fun to me, and no one ever seemed to have the
time to go in depth with it anyway. It was good practice at reading others'
code and understanding what it does. Learning new ways of accomplishing many
things that were unfamiliar. Getting used to seeing code that isn&rsquo;t formatted
<em>my way</em>, and accepting it for <em>what it is</em>. Learning how to utilize their code
from mine even when there is no explicitly exported clean API, and so forth.</p>

<p>But well it was the new-guy&rsquo;s day 3 today, and it seems we have really begun to
click as a duo. It is abundantly clear that he has a <em>wealth</em> of skills I lack.
Sure, he could definitely learn this code without my help, but I benefit a
great deal from seeing how he navigates it. What are the parts that he finds
especially confusing? The importance of variable names shines immediately
through. There are a few patches of code where I worked some Scala feature in
there just to try them out. Some of these turned out to be easier to understand
and reuse code from, and for some of them, something more cut-and-dry would
have been better.</p>

<p>Plus there&rsquo;s the fact that two minds are better than one. He&rsquo;s always
questioning my assumptions. To the point where he often straight up doesn&rsquo;t
believe what I say until I prove it. Sometimes he finds flaws in my arguments.
Sometimes, with my assumptions in hand, he invents better solutions to the
problem. Sometimes he understands what I did better than me and tells me its
advantages and disadvantages and alternatives.</p>

<p>My new partner&rsquo;s oft-stated goal is to get to a point where he can start
contributing to our project without my help, so that our concurrent efforts
will speed things along. People with a smart, helpful attitude like that have
been rare in my experience, so if he&rsquo;s being honest, I&rsquo;m all for taking him to
that place as quickly as I can.</p>

<p>I think maybe I just have a bias that everyone who doesn&rsquo;t know what I know
just wasn&rsquo;t smart enough to realize it. That is the thinking pattern of a real
asshole and this experience is making that abundantly clear. Everyone knows
that when learning something new, everything is always surprisingly confusing,
and then once it clicks, everything becomes &ldquo;trivial.&rdquo; However, I have not
spent much time teaching others, so I haven&rsquo;t had the opportunity to see this
&ldquo;click&rdquo; moment in others, and how dumb they all look before that moment occurs.
I do remember teachers explaining something, and me looking at it sideways in
confusion, and asking them to repeat it slower. This happened on many
occasions, and they must have thought I was a real idiot on each of those
occasions, but I was always so relieved when they did repeat, and I often would
strain my brain muscles and actually (partially) &ldquo;get it&rdquo; the second time
through.</p>

<p>The new-guy has taught me a lot from his attitude in joining a new team at a
new workplace. He&rsquo;s not trying to just &ldquo;set to work&rdquo; writing code willy-nilly
as quickly as possible. Compared to him, that&rsquo;s basically what I did. He wants
to <em>truly</em> understand what&rsquo;s going on. What does the architecture look like?
Who is the expert on what? Who is good at explaining things? Who is willing to
take the time to explain things? What do our users want? What do they expect?
What is the timeline? What has been built? What is he responsible for? What are
the alternative solutions that have been under consideration? Who has decision-
making power? Which teams do we collaborate with?</p>

<p>These are all questions that I know the answers to, as they are the necessary
fundamentals of how to operate and move forward. I started actively learning
the answers to these questions as soon as I arrived as well. However, I wasn&rsquo;t
as conscious and certainly not nearly as thorough at answering them as he is.
And over time I may have slipped a bit into a position of people trusting me to
do the right thing, so I don&rsquo;t feel as pressured to be on the ball with
everything at all times. But his arrival has been a reality check in the
importance of having a firm grip on the fundamentals of what are we doing and
why and how best to accomplish it in a strictly-business manner. There is no
excuse for losing one&rsquo;s professionalism, including having a &ldquo;casual&rdquo; workplace.</p>

<p>So far it has been 3 days. On a personal level of course I have learned more
during those 3 days of working with the new guy than I did during the previous
few weeks of working on my own. During this week I have probably also been
slower to accomplish those tasks remaining to finish before I leave. It is
firmly clear that this is a worthy tradeoff, and I will continue to spend the
rest of my time making sure that I am playing as great a part as possible in
his success in moving our project forward into the future. There maybe some
hiccups in our working relationship, because alas I barely know the guy, and
we&rsquo;re from different societal cultures, and my first impressions of people are
always notoriously off-base. However, now it is clear that the responsibility
is my own to make sure any future road-bumps are known to be my fault and my
problem and mine to fix with his help.</p>
]]></content>
  </entry>
  
</feed>
