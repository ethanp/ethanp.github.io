---
layout: post
title: "Gamified Learning"
date: 2016-01-03 21:34:05 -0800
comments: true
categories: [learning, gamification, points, levels, tutorials, motivation]
---

I have spent the last few days trying to get better at programming. I am no
longer in school, so if I want to learn about, say, compilers, I can't just
sign up for a class on that. There are multiple ways to go about it. It depends
on what you really want to learn and what you want to be able to do with that
knowledge. I have tried various methods of learning over the past few days,
which I have listed below.

What I have noticed of myself is that gamification __works__ for me. I love the
satisfaction of (in descending order of satisfaction)

* earning a badge
* getting to the next level
* beating other humans (directly, or via "percentile" calculation)
* beating robots (similar to "beating a boss" in a video game)
* getting points

Missing from the list below is Coursera, Udacity, etc. After 6 years of school,
I'm _really_ of sick of sitting in a lecture hall, even if it's a virtual one.
As a testament to this sentiment, so far I've read ~150 pages of the Compilers
textbook, which is the book I would be reading were I to take the class at
University. Sometimes I miss having a teacher whose personality I can associate
with the material. This is a bizarre notion, but it is really important. For
me, having a "great teacher" means someone I want to please by doing well on
the test. Having a "bad teacher" means I don't care what the teacher thinks of
me, and frankly I want to do badly to make them feel bad. This is a mean way of
looking at the world, and I don't do it consciously, but looking back at how I
approached my classes, this is what I did a lot of the time. Having a "great
teacher" is an amazing feeling, and an excellent motivator to really dig into
the subject. But I certainly _don't_ miss all the other crap that comes from
having a teacher (even a "great" one). The main problem with teachers is that
you need to be respectful of their time and the time of the other students in
the class. This leads to a huge amount of wasted time on the part of each
student, because his or her _particular_ questions aren't being answered. I
could go on about that but I won't. The point is, that I really
feel like I understand everything that has happened so far in the 150 pages of
the Compilers book, and it didn't require and physical hand-holding. It is
exceptionally easy to read a book and think you understand it, and actually
_not_ be understanding it. So who knows.

### Here on out

My first "real" day of my first "real" job is tomorrow. So I probably won't be
spending much time just randomly learning whatever I want in the future. But in
general, these are things that I like to learn about, and methods of learning
them that I enjoy doing, so as I find time, I will come back to these things.

### The List

This list contains bullets for each thing I have tried to learn over the past
few weeks. The sub-bullets contain methods I have used to actually _do_ the
learning. Many of them are gamified methods of learning (e.g. HackerRank).
Others, I have tried to gamify on my own (e.g. using test-driven development).

* Learn about compilers
    * read Compilers "Dragon Book" textbook
        * avg 8 pages per day for 20 days
    * do the exercises (on paper)
* Review AI & machine learning
    * earn an AI "badge" on HackerRank by 
        * doing statistics problems (e.g. "find the z-score")
        * writing a few programs (e.g. "do a multiple linear regression on the
          given data")
* Become more familiar with algorithms and their application
    * do practice problems on Hackerrank
    * Read [from] the algorithms textbook "CLRS"
* Become a "good programmer"
    * write the programs suggested in "Programming Pearls" by Jon Bentley
    * Beat bots and people at debugging code on `codefights.com`
* Learn via observation
    * `Livecoding.tv` (haven't actually looked into this one yet)
    * Annotate the code of small open source projects with comments explaining
      how it is working
        * substack -- creator of popular modules for Node.js
        * Li Haoyi -- Scala projects using concepts from compilers
* Understand P2P networking
    * Create a personal "open source" programming project that is a P2P
      networking application
        * To a large extent using test-driven development
* Learn to use NodeJS
    * do the `learnyounode` interactive tutorial
* Learn about functional programming
    * read from Learn you a Haskell
    * write some simple haskell programs as part of a "learn to code in 30
      days" competition on HackerRank
